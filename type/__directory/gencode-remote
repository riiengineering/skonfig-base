#!/bin/sh -e
#
# 2011-2013 Nico Schottelius (nico-cdist at schottelius.org)
# 2013 Steven Armstrong (steven-cdist armstrong.cc)
# 2014 Daniel Heule (hda at sfs.biz)
# 2020,2023 Dennis Camera (dennis.camera at riiengineering.ch)
#
# This file is part of skonfig-base.
#
# skonfig-base is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# skonfig-base is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with skonfig-base. If not, see <http://www.gnu.org/licenses/>.
#

. "${__type:?}/files/functions.sh"

destination="/${__object_id:?}"
state_should=$(cat "${__object:?}/parameter/state")
type=$(cat "${__object:?}/explorer/type")
stat_file="${__object:?}/explorer/stat"

# variable to keep track if we have to set directory attributes
set_attributes=false

recursive=
if test -f "${__object:?}/parameter/recursive"
then
	recursive='-R'
	# need to allways set attributes when recursive is given
	# as we don't want to check all subfolders/files
	set_attributes=true
fi

get_current_value() {
	if test -s "${stat_file}"
	then
		awk -v name="$1" -v value="$2" '{
			if (1 == index($0, name ":")) {
				if (value ~ /^[0-9]+$/) {
					print $2
				} else {
					print $3
				}
			}
		}' "${stat_file}"
	fi
}

set_group() {
	printf 'command -p chgrp %s%s %s\n' \
		"${recursive:+${recursive} }" "$1" "$(shquot "${destination}")"
	printf 'chgrp %s%s\n' \
		"${recursive:+${recursive} }" "$1" >>"${__messages_out:?}"
}

set_owner() {
	# XXX: need to quote owner:group?

	printf 'command -p chown %s%s %s\n' \
		"${recursive:+${recursive} }" "$1" "$(shquot "${destination}")"
	printf 'chown %s%s\n' \
		"${recursive:+${recursive} }" "$1" >>"${__messages_out:?}"
}

set_mode() {
	printf 'command -p chmod %s%s %s\n' \
		"${recursive:+${recursive} }" "$1" "$(shquot "${destination}")"
	printf 'chmod %s%s\n' \
		"${recursive:+${recursive} }" "$1" >>"${__messages_out:?}"
}

case ${state_should}
in
	(present|exists)
		if test "${type}" != 'directory'
		then
			set_attributes=true
			if test "${type}" != 'none'
			then
				# our destination is not a directory, remove whatever is there
				# and then create our directory and set all attributes
				printf 'rm -f %s\n' "$(shquot "${destination}")"
				echo "remove non directory" >>"${__messages_out:?}"
			fi

			mkdiropt=
			if test -f "${__object:?}/parameter/parents"
			then
				mkdiropt=' -p'
			fi

			printf 'mkdir%s %s\n' "${mkdiropt}" "$(shquot "${destination}")"
			echo create >>"${__messages_out:?}"
		elif test "${state_should}" = 'exists'
		then
			# The type is directory and --state exists. We are done and do not
			# check or set the attributes.
			exit 0
		fi

		# Note: Mode - needs to happen last as a chown/chgrp can alter mode by
		# clearing S_ISUID and S_ISGID bits (see chown(2))

		if test -f "${__object:?}/parameter/owner"
		then
			owner_should=$(cat "${__object:?}/parameter/owner")
			owner_is=$(get_current_value owner "${owner_should}")

			if test -f "${__object:?}/parameter/group"
			then
				group_should=$(cat "${__object:?}/parameter/group")
				group_is=$(get_current_value group "${group_should}")

				if ${set_attributes?} || test "${group_is}" != "${group_should}"
				then
					own=:${group_should}
				fi
			fi

			if ${set_attributes?} \
				|| test -n "${own-}" \
				|| test "${owner_is}" != "${owner_should}"
			then

				own=${owner_should}${own-}
			fi

			if test -n "${own-}"
			then
				set_owner "${own}"
			fi
		elif test -f "${__object:?}/parameter/group"
		then
			group_should=$(cat "${__object:?}/parameter/group")
			group_is=$(get_current_value group "${group_should}")

			if ${set_attributes?} || test "${group_should}" != "${group_is}"
			then
				set_group "${group_should}"
			fi
		fi

		if test -f "${__object:?}/parameter/mode"
		then
			mode_should=$(cat "${__object:?}/parameter/mode")
			mode_is=$(get_current_value mode "${mode_should}")

			# Convert to four-digit octal number (printf interprets
			# strings with leading 0s as octal!)
			mode_should=$(printf '%04o' "0${mode_should}")

			if ${set_attributes?} || test "${mode_should}" != "${mode_is}"
			then
				set_mode "${mode_should}"
			fi
		fi
		;;
	(pre-exists)
		case ${type}
		in
			(directory)
				# all good
				exit 0
				;;
			(none)
				printf 'Directory "%s" does not exist\n' "${destination}" >&2
				exit 1
				;;
			(file|symlink)
				printf 'File "%s" exists and is a %s, but should be a directory\n' "${destination}" "${type}" >&2
				exit 1
				;;
			(*)
				printf 'File or directory "%s" is in an unknown state\n' "${destination}" >&2
				exit 1
				;;
		esac
		;;
	(absent)
		case ${type}
		in
			(directory)
				printf 'rm -R -f %s\n' "$(shquot "${destination}")"
				echo remove >>"${__messages_out:?}"
				;;
		esac
		;;
	(*)
		printf 'Invalid --state: %s\n' "${state_should}" >&2
		exit 1
		;;
esac
