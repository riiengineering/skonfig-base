#!/bin/sh -e
#
# 2020,2022,2024 Dennis Camera (dennis.camera at riiengineering.ch)
#
# This file is part of skonfig-base.
#
# skonfig-base is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# skonfig-base is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with skonfig-base. If not, see <http://www.gnu.org/licenses/>.
#
# Determines the current state of the config option.
#
# Possible output:
#   present
#     "should" option present in config file
#   default
#     the "should" option is the default -> donâ€™t know if present
#   absent
#     no such option present in config file
#

joinlines() { sed -n -e H -e "\${x;s/^\\n//;s/\\n/${1:?}/g;p;}"; }
trlower() { tr '[:upper:]' '[:lower:]'; }
tolower() { printf '%s' "$*" | trlower; }

# NOTE: Old versions of sshd(8) don't allow to be executed from PATH even if
#       just for checking the config file's syntax.
#       So while checking for sshd's presence also extract its path.
sshd=$(command -v sshd 2>/dev/null) || {
	echo 'Cannot find sshd(8).' >&2
	exit 1
}
# NOTE: even if -V is an invalid option (OpenSSH < 9.2) it allows execution of
#       sshd without using an absolute path, and more importantly it will
#       not start an actual SSH daemon.
#       When -V is not supported, we extract the version number from the
#       usage message.
openssh_version=$(
	sshd -V 2>&1 \
	| sed -n -e 's/^\(sshd version \)\{0,1\}OpenSSH_\([^, ]*\).*$/\2/p')

sshd_config_file=$("${__type_explorer:?}/config_file")
test -e "${sshd_config_file}" || {
	echo 'absent'
	exit 0
}

grep_cfg_value() {
	awk -v k="$1" 'tolower(k)==$1 { $1=""; sub(/^[[:blank:]]*/, ""); print }'
}

conf_get_value() {
	"${sshd:?}" -T -f "${1:?}" ${sshd_conn_spec:+-C "${sshd_conn_spec}"} \
	| grep_cfg_value "${2:?}"
}

is_sshd_version_ge() {
	# This function only compares the numeric parts of the version number!
	printf '%s\n' "${openssh_version%%[!0-9.]*}" "${1%%[!0-9.]*}" \
	| sort -t . -k 1,1n -k 2,2n -k 3,3n \
	| head -n1 \
	| grep -qxF -e "${1%%[!0-9.]*}"
}

state_should=$(cat "${__object:?}/parameter/state")

if test -s "${__object:?}/parameter/option"
then
	read -r option_name <"${__object:?}/parameter/option"
else
	option_name=${__object_id:?}
fi
if { read -r value_should <"${__object:?}/parameter/value"; } 2>/dev/null
then
	value_should=${value_should#\\}
elif test "${state_should}" != absent
then
	# parameter --value is optional for --state absent only
	printf 'Parameter --value is required for --state %s!\n' "${state_should}" >&2
	exit 1
fi

sshd_conn_spec=$(
	if test -s "${__object:?}/parameter/match"
	then
		_match_file="${__object:?}/parameter/match"
	else
		_match_file=/dev/null
	fi

	set --
	if is_sshd_version_ge 4.4
	then
		# Match blocks in sshd_config(5) have been added in OpenSSH 4.4
		set -- "$@" \
			addr=Address \
			user=User \
			host=Host
	elif test -s "${__object:?}/parameter/match"
	then
		echo 'OpenSSH installed on the target does not support --match.' >&2
		exit 1
	fi

	if is_sshd_version_ge 6.1
	then
		set -- "$@" \
			laddr=LocalAddress \
			lport=LocalPort
	fi

	if is_sshd_version_ge 7.7
	then
		set -- "$@" \
			rdomain=RDomain
	fi

	for _kw in "$@"
	do
		_specname=${_kw%%=*}
		_confname=$(tolower "${_kw#*=}")
		while read -r _k _v
		do
			if test "$(tolower "${_k}")" = "${_confname}"
			then
				printf '%s=%s\n' "${_specname}" "${_v}"
				continue 2
			fi
		done <"${_match_file}"

		# NOTE: Print test spec even for empty keys to suppress errors like:
		#  'Match User' in configuration but 'user' not in connection test specification.
		# except lport:
		#  Invalid port '' in test mode specification lport=
		case ${_specname}
		in
			(lport)
				;;
			(*)
				printf '%s=\n' "${_specname}" ;;
		esac
	done \
	| joinlines ','
) || exit

default_value=$(
	# NOTE: this weird construct is to save the exit status of sshd(8) to
	#       detect support for the -T option.
	defaults=$("${sshd}" -T -f /dev/null ${sshd_conn_spec:+-C "${sshd_conn_spec}"} 2>/dev/null) || exit
	grep_cfg_value "${option_name}" <<-EOF
	${defaults}
	EOF
) || {
	# OpenSSH < 5.1 detected :-)
	sshd_has_exttest=false
}

test -d "${__object:?}/files" || mkdir "${__object:?}/files"

if ${sshd_has_exttest:-true}
then
	value_is=$(conf_get_value "${sshd_config_file}" "${option_name}")

	if test -n "${value_should-}"
	then
		# convert given value to the value reported by sshd -T (this is required
		# to compare values with different names, e.g. prohibit-password or
		# delta values like "Ciphers -md5")

		{
			if test -s "${__object:?}/parameter/match"
			then
				printf 'Match %s\n' "$(joinlines ' ' <"${__object:?}/parameter/match")"
			fi
			printf '%s %s\n' "${option_name}" "${value_should}"
		} >"${__object:?}/files/optline.tmp"

		value_should=$(conf_get_value "${__object:?}/files/optline.tmp" "${option_name}")
		rm -f "${__object:?}/files/optline.tmp"
	fi
else
	# This system uses an ancient version of sshd(8) which does not support
	# the -T option.  We'll parse the sshd_config file manually as good as
	# we can *shrug*
	value_is=$(
		if test -s "${__object:?}/parameter/match"
		then
			_match_line=$(joinlines ' ' <"${__object:?}/parameter/match")
		fi
		awk -v match_spec="${_match_line-}" -v option="${option_name}" '
		BEGIN {
			option_l = tolower(option)

			if (match_spec) {
				match_l = tolower(match_spec)
			} else {
				m = 1
			}
		}

		$1 ~ /^[Mm]atch$/ {
			$1 = ""; sub(/^ /, "")
			m = (match_l == tolower($0))
			next
		}

		m && option_l == tolower($1) {
			$1 = ""; sub(/^ /, "")
			v = v RS $0
		}
		END { if (v) { print v } }
		' "${sshd_config_file}")
fi

if test -n "${value_should-}"
then
	test "${value_is}" = "${value_should}"
else
	# if no --value provided, assume "any" value is fine
	test -n "${value_is}"
fi && is_match=true || is_match=false

if ${is_match?}
then
	if test "${value_is}" = "${default_value:-not ${value_is}}"
	then
		# Might produce false positives for default values.
		# TODO: Manual checking should be done, but for simplicity, this case is
		#       currently ignored here.
		echo default
	else
		echo present
	fi
else
	echo absent
fi
