#!/bin/sh -e
#
# 2020,2022,2024 Dennis Camera (dennis.camera at riiengineering.ch)
#
# This file is part of skonfig-base.
#
# skonfig-base is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# skonfig-base is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with skonfig-base. If not, see <http://www.gnu.org/licenses/>.
#
# Determines the current state of the config option.
# Possible output:
#  - present: "should" option present in config file
#  - default: the "should" option is the default -> donâ€™t know if present
#  - absent: no such option present in config file
#

joinlines() { sed -n -e H -e "\${x;s/^\\n//;s/\\n/${1:?}/g;p;}"; }
trlower() { tr '[:upper:]' '[:lower:]'; }
tolower() { printf '%s' "$*" | trlower; }

grep_cfg_value() {
	awk -v k="$1" 'tolower(k)==$1 { $1=""; sub(/^[[:blank:]]*/, ""); print }'
}

# NOTE: Old versions of sshd(8) don't allow to be executed from PATH even if
#       just for checking the config file's syntax.
#       So while checking for sshd's presence also extract its path.
sshd=$(command -v sshd 2>/dev/null) || {
	echo 'Cannot find sshd(8).' >&2
	exit 0
}

sshd_config_file=$("${__type_explorer:?}/config_file")
test -e "${sshd_config_file}" || {
	echo 'absent'
	exit 0
}

read -r state_should <"${__object:?}/parameter/state"
if test -s "${__object:?}/parameter/option"
then
	read -r option_name <"${__object:?}/parameter/option"
else
	option_name=${__object_id:?}
fi
if { read -r value_should <"${__object:?}/parameter/value"; } 2>/dev/null
then
	value_should=${value_should#\\}
elif test "${state_should}" != absent
then
	# parameter --value is optional for --state absent only
	printf 'Parameter --value is required for --state %s!\n' "${state_should}" >&2
	exit 1
fi

sshd_conn_spec=$(
	if test -s "${__object:?}/parameter/match"
	then
		_match_file="${__object:?}/parameter/match"
	else
		_match_file='/dev/null'
	fi

	for _kw in \
		addr=Address \
		user=User \
		host=Host \
		laddr=LocalAddress \
		lport=LocalPort \
		rdomain=RDomain
	do
		_specname=${_kw%%=*}
		_confname=$(tolower "${_kw#*=}")
		while read -r _k _v
		do
			if test "$(tolower "${_k}")" = "${_confname}"
			then
				printf '%s=%s\n' "${_specname}" "${_v}"
				continue 2
			fi
		done <"${_match_file}"

		# NOTE: Print test spec even for empty keys to suppress errors like:
		#  'Match User' in configuration but 'user' not in connection test specification.
		# except lport:
		#  Invalid port '' in test mode specification lport=
		case ${_specname}
		in
			(lport)
				;;
			(*)
				printf '%s=\n' "${_specname}" ;;
		esac
	done \
	| joinlines ','
)

default_value=$(
	# NOTE: this weird construction is to save the exit status of sshd(8) to
	#       detect support for the -T option.
	defaults=$("${sshd}" -T -f /dev/null -C "${sshd_conn_spec}") || exit
	grep_cfg_value "${option_name}" <<-EOF
	${defaults}
	EOF
) || {
	# OpenSSH < 5.1 detected :-)
	sshd_has_exttest=false
}

test -d "${__object:?}/files" || mkdir "${__object:?}/files"

if ${sshd_has_exttest:-true}
then
	value_is=$(
		"${sshd}" -T -f "${sshd_config_file}" -C "${sshd_conn_spec}" \
		| grep_cfg_value "${option_name}")

	if test -n "${value_should}"
	then
		# convert given value to the value reported by sshd -T (this is required
		# to compare values with different names, e.g. prohibit-password or
		# delta values like "Ciphers -md5")

		{
			if test -s "${__object:?}/parameter/match"
			then
				printf 'Match %s\n' "$(joinlines ' ' <"${__object:?}/parameter/match")"
			fi
			printf '%s %s\n' "${option_name}" "${value_should}"
		} >"${__object:?}/files/optline.tmp"

		value_should=$(
			"${sshd}" -T -f "${__object:?}/files/optline.tmp" -C "${sshd_conn_spec}" \
			| grep_cfg_value "${option_name}")
		rm -f "${__object:?}/files/optline.tmp"
	fi
else
	# This system uses an ancient version of sshd(8) which does not support
	# the -T option.  We'll parse the sshd_config file manually as good as
	# we can *shrug*
	value_is=$(
		_match_line=$(joinlines ' ' <"${__object:?}/parameter/match")
		awk -v match_spec="${_match_line}" -v option="${option_name}" '
		BEGIN {
			option_l = tolower(option)

			if (match_spec) {
				match_l = tolower(match_spec)
			} else {
				m = 1
			}
		}

		$1 ~ /^[Mm]atch$/ {
			$1 = ""; sub(/^ /, "")
			m = (match_l == tolower($0))
			next
		}

		m && option_l == tolower($1) {
			$1 = ""; sub(/^ /, "")
			v = v RS $0
		}
		END { if (v) { print v } }
		' "${sshd_config_file}")
fi


if printf '%s\n' "${value_is}" | {
		case ${value_should}
		in
			(?*)
				# NOTE: -e is important to work around BusyBox option parser bug when value begins with -:
				#       $ grep -F '-*md5*' /etc/ssh/sshd_config
				#       grep: invalid option -- '*'
				#       BusyBox v1.30.1 (2020-02-19 11:54:49 UTC) multi-call binary.
				#       ...
				#
				#       $ grep -F -e '-*md5*' /etc/ssh/sshd_config
				#       ...
				grep -q -x -F -e "${value_should}" ;;
			(*)
				# if no --value is provided, assume "any" value
				grep -q -e '.' ;;
		esac
	}
then
	if test "${value_is}" = "${default_value:-not ${value_is}}"
	then
		# Might produce false positives for default values.
		# TODO: Manual checking should be done, but for simplicity, this case is
		#       currently ignored here.
		echo default
	else
		echo present
	fi
else
	echo absent
fi
